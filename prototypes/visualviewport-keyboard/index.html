<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, interactive-widget=resizes-content">
    <title>visualViewport Keyboard v11</title>
    <script>
        // Polyfill crypto.randomUUID for HTTP
        if (typeof crypto !== 'undefined' && !crypto.randomUUID) {
            crypto.randomUUID = function() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
                });
            };
        }
    </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html, body {
            height: 100%;
            overflow: hidden;
            background: #1e1e1e;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }

        :root {
            --keyboard-height: 0px;
            --viewport-height: 100vh;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            /* No transition - immediate resize for terminal fit */
        }

        /* Debug bars */
        .debug {
            position: fixed;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            color: #0f0;
            font-family: monospace;
            font-size: 11px;
            padding: 6px 10px;
            z-index: 100;
        }
        .debug:nth-child(1) { top: 0; }
        .debug:nth-child(2) { top: 24px; background: rgba(0, 0, 80, 0.9); color: #0ff; }
        .debug:nth-child(3) { top: 48px; background: rgba(80, 0, 0, 0.9); color: #f80; }

        .terminal-wrapper {
            position: absolute;
            top: 72px; /* space for debug bars */
            left: 0;
            right: 0;
            /* bottom is set dynamically by JS */
            bottom: 60px; /* default: space for input bar only */
            overflow: hidden;
        }

        #terminal {
            position: absolute;
            inset: 0;
            transition: transform 0.1s ease-out;
        }

        /* === TOUCH SCROLL PROXY === */
        .touch-scroll-proxy {
            position: absolute;
            inset: 0;
            overflow-y: scroll;
            overflow-x: hidden;
            z-index: 10;
            -webkit-overflow-scrolling: touch;
        }
        .touch-scroll-proxy::-webkit-scrollbar {
            display: none;
        }
        .scroll-spacer {
            width: 100%;
            pointer-events: none;
            min-height: 3000px;
        }

        @media (pointer: coarse) {
            .touch-scroll-proxy {
                display: block;
                pointer-events: auto !important;
            }
            #terminal, #terminal *, .xterm, .xterm *,
            .xterm-viewport, .xterm-screen, .xterm-helper-textarea {
                pointer-events: none !important;
            }
        }
        @media (pointer: fine) {
            .touch-scroll-proxy {
                display: none;
            }
        }

        /* Mobile input bar - FIXED at bottom, moves with keyboard */
        .input-bar {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            gap: 8px;
            padding: 10px;
            background: #2d2d2d;
            border-top: 1px solid #444;
            z-index: 50;
            /* Will be transformed up when keyboard shows */
            transform: translateY(calc(-1 * var(--keyboard-offset, 0px)));
            transition: transform 0.1s ease-out;
        }
        .input-bar input {
            flex: 1;
            padding: 12px 14px;
            font-size: 16px; /* prevents iOS zoom */
            font-family: monospace;
            background: #1a1a1a;
            color: #fff;
            border: 2px solid #444;
            border-radius: 6px;
        }
        .input-bar input:focus {
            border-color: #007acc;
            outline: none;
        }
        .input-bar button {
            padding: 12px 20px;
            font-size: 16px;
            font-weight: bold;
            background: #007acc;
            color: #fff;
            border: none;
            border-radius: 6px;
        }

        /* Keyboard visible indicator */
        .keyboard-indicator {
            position: fixed;
            bottom: var(--keyboard-height);
            left: 0;
            right: 0;
            height: 4px;
            background: #f00;
            z-index: 200;
            transition: bottom 0.1s ease-out;
        }
    </style>
</head>
<body>
    <div class="debug" id="debug1">v10 | Loading...</div>
    <div class="debug" id="debug2">visualViewport: ...</div>
    <div class="debug" id="debug3">keyboard: ...</div>

    <!-- Red line showing where keyboard starts -->
    <div class="keyboard-indicator"></div>

    <div class="container" id="container">
        <div class="terminal-wrapper">
            <div id="terminal"></div>
            <div class="touch-scroll-proxy" id="scrollProxy">
                <div class="scroll-spacer" id="scrollSpacer"></div>
            </div>
        </div>
    </div>

    <!-- Input bar is OUTSIDE container, fixed position -->
    <div class="input-bar">
        <input type="text" id="cmdInput" placeholder="Tap here to show keyboard..."
            autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false">
        <button id="sendBtn">Send</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <script>
        const debug1 = document.getElementById('debug1');
        const debug2 = document.getElementById('debug2');
        const debug3 = document.getElementById('debug3');
        const container = document.getElementById('container');
        const cmdInput = document.getElementById('cmdInput');
        const sendBtn = document.getElementById('sendBtn');
        const scrollProxy = document.getElementById('scrollProxy');
        const scrollSpacer = document.getElementById('scrollSpacer');
        const terminalEl = document.getElementById('terminal');

        // Xterm setup
        const term = new Terminal({
            cursorBlink: true,
            fontSize: 14,
            fontFamily: 'Menlo, Monaco, "Courier New", monospace',
            scrollback: 5000,
            theme: {
                background: '#1e1e1e',
                foreground: '#ffffff',
                cursor: '#ffffff'
            }
        });

        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        term.open(document.getElementById('terminal'));
        fitAddon.fit();

        // WebSocket
        const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        const ws = new WebSocket(`${protocol}//${location.host}/ws`);

        ws.onopen = () => {
            debug1.textContent = 'v11 | Connected - generating text...';
            sendResize();

            // Generate 150 lines - SHORT to avoid wrap
            setTimeout(() => {
                ws.send('clear\r');
            }, 200);
            setTimeout(() => {
                ws.send('for i in $(seq 1 150); do printf "%3d | Line %d here\\n" $i $i; done\r');
            }, 400);
        };

        ws.onmessage = (e) => {
            if (e.data instanceof Blob) {
                e.data.arrayBuffer().then(buf => term.write(new Uint8Array(buf)));
            } else {
                term.write(e.data);
            }
        };

        ws.onclose = () => {
            debug1.textContent = 'v11 | Disconnected';
        };

        term.onData(data => {
            if (ws.readyState === WebSocket.OPEN) ws.send(data);
        });

        function sendResize() {
            if (ws.readyState === WebSocket.OPEN) {
                ws.send(`resize:${term.cols}x${term.rows}`);
            }
        }

        // === TOUCH SCROLL PROXY ===
        const lineHeight = 17; // approximate
        let syncingFromProxy = false;
        let syncingFromTerm = false;

        function updateSpacerHeight() {
            const bufferLines = term.buffer.active.length;
            const height = Math.max(bufferLines * lineHeight, 3000);
            scrollSpacer.style.height = `${height}px`;
        }

        function syncProxyToTerm() {
            if (syncingFromTerm) return;
            syncingFromProxy = true;

            const maxScroll = scrollProxy.scrollHeight - scrollProxy.clientHeight;
            const scrollTop = scrollProxy.scrollTop;

            // Rubber band effect
            if (scrollTop < 0) {
                terminalEl.style.transform = `translateY(${Math.min(-scrollTop * 0.5, 100)}px)`;
            } else if (scrollTop > maxScroll) {
                terminalEl.style.transform = `translateY(${Math.max((maxScroll - scrollTop) * 0.5, -100)}px)`;
            } else {
                terminalEl.style.transform = 'translateY(0)';
            }

            if (maxScroll > 0) {
                const scrollRatio = Math.max(0, Math.min(1, scrollTop / maxScroll));
                const maxLine = term.buffer.active.length - term.rows;
                term.scrollToLine(Math.round(scrollRatio * maxLine));
            }

            requestAnimationFrame(() => { syncingFromProxy = false; });
        }

        function syncTermToProxy() {
            if (syncingFromProxy) return;
            syncingFromTerm = true;
            const maxLine = term.buffer.active.length - term.rows;
            if (maxLine > 0) {
                const scrollRatio = term.buffer.active.viewportY / maxLine;
                const maxScroll = scrollProxy.scrollHeight - scrollProxy.clientHeight;
                scrollProxy.scrollTop = scrollRatio * maxScroll;
            }
            requestAnimationFrame(() => { syncingFromTerm = false; });
        }

        scrollProxy.addEventListener('scroll', syncProxyToTerm, { passive: true });
        term.onScroll(syncTermToProxy);
        term.onWriteParsed(updateSpacerHeight);
        scrollProxy.addEventListener('click', () => term.focus());

        // === VISUALVIEWPORT KEYBOARD HANDLING ===

        const inputBar = document.querySelector('.input-bar');
        const terminalWrapper = document.querySelector('.terminal-wrapper');
        let lastKeyboardHeight = 0;

        // Store original height BEFORE keyboard can appear
        const originalWindowHeight = window.innerHeight;

        function updateViewport() {
            const vv = window.visualViewport;
            if (!vv) {
                debug2.textContent = 'visualViewport: NOT SUPPORTED';
                return;
            }

            // Use ORIGINAL window height as reference since interactive-widget
            // causes window.innerHeight to shrink with keyboard
            const keyboardHeight = Math.max(0, originalWindowHeight - vv.height);
            const keyboardVisible = keyboardHeight > 50;

            // Position input bar above keyboard
            inputBar.style.bottom = `${keyboardHeight}px`;

            // Set terminal-wrapper bottom directly
            // When keyboard visible: above keyboard (keyboardHeight) + input bar (60)
            // When hidden: just above input bar (60)
            const wrapperBottom = keyboardVisible ? keyboardHeight + 60 : 60;
            terminalWrapper.style.bottom = `${wrapperBottom}px`;

            // Debug output
            debug2.textContent = `vv: h=${vv.height.toFixed(0)} orig=${originalWindowHeight} wrapperBot=${wrapperBottom}`;
            debug3.textContent = `kb: ${keyboardVisible ? 'VISIBLE' : 'hidden'} height=${keyboardHeight.toFixed(0)}px`;

            // Refit terminal after layout changes
            if (Math.abs(keyboardHeight - lastKeyboardHeight) > 20) {
                lastKeyboardHeight = keyboardHeight;
                // Immediate refit - no transition needed
                requestAnimationFrame(() => {
                    fitAddon.fit();
                    sendResize();
                    term.scrollToBottom();
                    updateSpacerHeight();
                });
            }
        }

        // Listen to visualViewport events
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', updateViewport);
            window.visualViewport.addEventListener('scroll', updateViewport);
            updateViewport();
        } else {
            debug2.textContent = 'visualViewport: NOT SUPPORTED in this browser';
        }

        // Also handle regular resize
        window.addEventListener('resize', () => {
            updateViewport();
            fitAddon.fit();
            sendResize();
        });

        // Input handling
        sendBtn.addEventListener('click', () => {
            if (ws.readyState === WebSocket.OPEN && cmdInput.value) {
                ws.send(cmdInput.value + '\r');
                cmdInput.value = '';
            }
        });

        cmdInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                sendBtn.click();
            }
        });

        // Track focus - and scroll window to top to prevent iOS scroll weirdness
        cmdInput.addEventListener('focus', () => {
            debug1.textContent = 'v11 | Input FOCUSED';
            // Prevent iOS from scrolling page - scroll to top instead
            setTimeout(() => {
                window.scrollTo(0, 0);
                updateViewport();
            }, 100);
        });
        cmdInput.addEventListener('blur', () => {
            debug1.textContent = 'v11 | Input BLURRED';
            setTimeout(() => {
                window.scrollTo(0, 0);
                updateViewport();
            }, 100);
        });

        debug1.textContent = 'v11 | Ready - tap input to test keyboard';
    </script>
</body>
</html>
