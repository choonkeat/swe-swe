package main

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/fsnotify/fsnotify"
)

const proxyDir = ".swe-swe/proxy"

// containerScriptTemplate is the bash script generated for containers to submit requests.
// It uses NUL-delimited arguments and inotifywait for efficient waiting.
const containerScriptTemplate = `#!/usr/bin/env bash
set -euo pipefail

# Container script for proxying '%s' commands to host
# Generated by: swe-swe proxy %s

PROXY_DIR="${PROXY_DIR:-.swe-swe/proxy}"
TIMEOUT="${PROXY_TIMEOUT:-300}"

# Generate unique request ID
uuid=$(cat /proc/sys/kernel/random/uuid)
req_file="$PROXY_DIR/$uuid.req"
tmp_file="$PROXY_DIR/$uuid.req.tmp"
exit_file="$PROXY_DIR/$uuid.exit"
stdout_file="$PROXY_DIR/$uuid.stdout"
stderr_file="$PROXY_DIR/$uuid.stderr"

# Write request atomically (NUL-delimited arguments)
if [[ $# -gt 0 ]]; then
    printf '%%s\0' "$@" > "$tmp_file"
else
    # No arguments - create empty request file
    touch "$tmp_file"
fi
mv "$tmp_file" "$req_file"

# Wait for response using inotifywait
# The exit file appears last, signaling completion
deadline=$((SECONDS + TIMEOUT))
while [[ ! -f "$exit_file" ]]; do
    if ((SECONDS >= deadline)); then
        echo "ERROR: Timeout waiting for host to execute command" >&2
        rm -f "$req_file" 2>/dev/null || true
        exit 124
    fi
    # Use inotifywait if available, otherwise fall back to polling
    if command -v inotifywait &>/dev/null; then
        inotifywait -qq -t 1 -e create -e moved_to "$PROXY_DIR" 2>/dev/null || true
    else
        sleep 0.1
    fi
done

# Output results
[[ -f "$stdout_file" ]] && cat "$stdout_file"
[[ -f "$stderr_file" ]] && cat "$stderr_file" >&2
exit_code=$(cat "$exit_file")

# Cleanup response files
rm -f "$stdout_file" "$stderr_file" "$exit_file"

exit "$exit_code"
`

// handleProxy implements the `swe-swe proxy <command>` subcommand.
// It creates a file-based proxy that allows containers to execute
// the specified command on the host and receive stdout/stderr/exit code.
func handleProxy() {
	if len(os.Args) < 3 {
		fmt.Fprintf(os.Stderr, "Usage: swe-swe proxy <command>\n\n")
		fmt.Fprintf(os.Stderr, "Starts a proxy that allows containers to execute <command> on the host.\n")
		fmt.Fprintf(os.Stderr, "The container can then run .swe-swe/proxy/<command> with arguments.\n\n")
		fmt.Fprintf(os.Stderr, "Example:\n")
		fmt.Fprintf(os.Stderr, "  Host:      swe-swe proxy make\n")
		fmt.Fprintf(os.Stderr, "  Container: .swe-swe/proxy/make build TARGET=hello\n")
		os.Exit(1)
	}

	command := os.Args[2]

	// Validate command is not empty
	if command == "" {
		fmt.Fprintf(os.Stderr, "Error: command cannot be empty\n")
		os.Exit(1)
	}

	// Create proxy directory if needed
	if err := os.MkdirAll(proxyDir, 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Error: failed to create proxy directory: %v\n", err)
		os.Exit(1)
	}

	pidFile := filepath.Join(proxyDir, command+".pid")
	scriptFile := filepath.Join(proxyDir, command)

	// Check for existing PID file
	if err := checkAndClaimPIDFile(pidFile, command); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	// Generate container script
	if err := generateContainerScript(scriptFile, command); err != nil {
		os.Remove(pidFile)
		fmt.Fprintf(os.Stderr, "Error: failed to generate container script: %v\n", err)
		os.Exit(1)
	}

	// Set up signal handling for graceful shutdown
	ctx, cancel := context.WithCancel(context.Background())
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

	go func() {
		sig := <-sigChan
		fmt.Printf("\n[proxy] Received signal %v, shutting down...\n", sig)
		cancel()
	}()

	// Ensure cleanup on exit
	defer func() {
		os.Remove(scriptFile)
		os.Remove(pidFile)
		fmt.Printf("[proxy] Cleaned up script and PID file\n")
	}()

	// Clean up orphan response files from previous runs
	cleanupOrphanFiles(proxyDir)

	fmt.Printf("[proxy] Starting proxy for command: %s\n", command)
	fmt.Printf("[proxy] Container script: %s\n", scriptFile)
	fmt.Printf("[proxy] PID file: %s\n", pidFile)
	fmt.Printf("[proxy] Watching for requests in: %s\n", proxyDir)

	// Set up file watcher
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: failed to create file watcher: %v\n", err)
		os.Exit(1)
	}
	defer watcher.Close()

	// Watch the proxy directory
	if err := watcher.Add(proxyDir); err != nil {
		fmt.Fprintf(os.Stderr, "Error: failed to watch directory: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("[proxy] Listening for '%s' commands... (Ctrl+C to stop)\n", command)

	// WaitGroup for in-flight requests
	var wg sync.WaitGroup

	// Main event loop
	for {
		select {
		case <-ctx.Done():
			fmt.Printf("[proxy] Shutting down gracefully, waiting for in-flight requests...\n")
			wg.Wait()
			fmt.Printf("[proxy] All requests completed\n")
			return

		case event, ok := <-watcher.Events:
			if !ok {
				wg.Wait()
				return
			}

			// We're interested in Create and Rename (moved_to) events for .req files
			if event.Op&(fsnotify.Create|fsnotify.Rename) != 0 {
				if strings.HasSuffix(event.Name, ".req") {
					uuid := strings.TrimSuffix(filepath.Base(event.Name), ".req")
					fmt.Printf("[proxy] Received request: %s\n", uuid)
					wg.Add(1)
					go func(uuid string) {
						defer wg.Done()
						processRequest(command, uuid)
					}(uuid)
				}
			}

		case err, ok := <-watcher.Errors:
			if !ok {
				wg.Wait()
				return
			}
			fmt.Fprintf(os.Stderr, "[proxy] Watcher error: %v\n", err)
		}
	}
}

// generateContainerScript writes the container script to the specified path.
func generateContainerScript(path, command string) error {
	script := fmt.Sprintf(containerScriptTemplate, command, command)
	if err := os.WriteFile(path, []byte(script), 0755); err != nil {
		return fmt.Errorf("failed to write script: %w", err)
	}
	return nil
}

// processRequest handles a single proxy request:
// 1. Read NUL-delimited args from <uuid>.req
// 2. Delete .req file (claim it)
// 3. Execute command with args
// 4. Write stdout, stderr, and exit code to response files
func processRequest(command, uuid string) {
	reqFile := filepath.Join(proxyDir, uuid+".req")
	stdoutFile := filepath.Join(proxyDir, uuid+".stdout")
	stderrFile := filepath.Join(proxyDir, uuid+".stderr")
	exitFile := filepath.Join(proxyDir, uuid+".exit")

	// Read the request file
	data, err := os.ReadFile(reqFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "[proxy] Failed to read request %s: %v\n", uuid, err)
		// Write error to response files
		os.WriteFile(stderrFile, []byte(fmt.Sprintf("Failed to read request: %v\n", err)), 0644)
		os.WriteFile(stdoutFile, []byte{}, 0644)
		os.WriteFile(exitFile, []byte("1"), 0644)
		return
	}

	// Delete request file (claim it)
	os.Remove(reqFile)

	// Parse NUL-delimited arguments
	args := parseNulDelimitedArgs(data)
	fmt.Printf("[proxy] Executing: %s %v\n", command, args)

	// Execute the command
	cmd := exec.Command(command, args...)

	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	err = cmd.Run()

	// Determine exit code
	exitCode := 0
	if err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok {
			exitCode = exitErr.ExitCode()
		} else {
			// Command failed to start (e.g., not found)
			exitCode = 127
			stderr.WriteString(fmt.Sprintf("Failed to execute command: %v\n", err))
		}
	}

	fmt.Printf("[proxy] Command exited with code: %d\n", exitCode)

	// Write response files (exit file last to signal completion)
	if err := os.WriteFile(stdoutFile, stdout.Bytes(), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "[proxy] Failed to write stdout: %v\n", err)
	}
	if err := os.WriteFile(stderrFile, stderr.Bytes(), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "[proxy] Failed to write stderr: %v\n", err)
	}
	if err := os.WriteFile(exitFile, []byte(strconv.Itoa(exitCode)), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "[proxy] Failed to write exit code: %v\n", err)
	}
}

// parseNulDelimitedArgs splits a NUL-delimited byte slice into arguments.
// Empty input returns nil (no arguments).
// Trailing NUL bytes are handled gracefully.
func parseNulDelimitedArgs(data []byte) []string {
	if len(data) == 0 {
		return nil
	}

	// Split on NUL bytes
	parts := bytes.Split(data, []byte{0})

	// Filter out empty strings (handles trailing NUL)
	var args []string
	for _, part := range parts {
		if len(part) > 0 {
			args = append(args, string(part))
		}
	}

	return args
}

// checkAndClaimPIDFile checks if a proxy is already running for this command.
// If a stale PID file exists (process dead), it removes it.
// If the process is still running, it returns an error.
// Otherwise, it writes the current PID to the file.
func checkAndClaimPIDFile(pidFile, command string) error {
	// Check if PID file exists
	data, err := os.ReadFile(pidFile)
	if err == nil {
		// PID file exists, check if process is running
		pid, err := strconv.Atoi(strings.TrimSpace(string(data)))
		if err != nil {
			// Invalid PID file content, remove it
			fmt.Printf("[proxy] Removing invalid PID file: %s\n", pidFile)
			os.Remove(pidFile)
		} else {
			// Check if process is alive using signal 0
			process, err := os.FindProcess(pid)
			if err == nil {
				// On Unix, FindProcess always succeeds, so we need to send signal 0
				err = process.Signal(syscall.Signal(0))
				if err == nil {
					// Process is still running
					return fmt.Errorf("proxy for '%s' already running (PID %d)", command, pid)
				}
			}
			// Process is dead, remove stale PID file
			fmt.Printf("[proxy] Removing stale PID file (PID %d no longer running)\n", pid)
			os.Remove(pidFile)
		}
	} else if !os.IsNotExist(err) {
		return fmt.Errorf("failed to read PID file: %v", err)
	}

	// Write our PID to the file
	currentPID := os.Getpid()
	if err := os.WriteFile(pidFile, []byte(strconv.Itoa(currentPID)), 0644); err != nil {
		return fmt.Errorf("failed to write PID file: %v", err)
	}

	return nil
}

// cleanupOrphanFiles removes orphan response files older than 5 minutes.
// Orphans can occur when:
// - Container crashed after submitting request but before reading response
// - Host crashed after writing response but before container read it
// We only clean up response files (.stdout, .stderr, .exit), not .req files
// since those might be legitimate pending requests.
func cleanupOrphanFiles(dir string) {
	const maxAge = 5 * time.Minute

	entries, err := os.ReadDir(dir)
	if err != nil {
		// Directory might not exist yet, that's fine
		return
	}

	now := time.Now()
	orphanSuffixes := []string{".stdout", ".stderr", ".exit"}

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		name := entry.Name()
		isOrphanCandidate := false
		for _, suffix := range orphanSuffixes {
			if strings.HasSuffix(name, suffix) {
				isOrphanCandidate = true
				break
			}
		}

		if !isOrphanCandidate {
			continue
		}

		info, err := entry.Info()
		if err != nil {
			continue
		}

		age := now.Sub(info.ModTime())
		if age > maxAge {
			path := filepath.Join(dir, name)
			if err := os.Remove(path); err == nil {
				fmt.Printf("[proxy] Removed orphan file: %s (age: %v)\n", name, age.Round(time.Second))
			}
		}
	}
}
