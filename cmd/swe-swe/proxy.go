package main

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"
	"syscall"
	"time"

	"github.com/fsnotify/fsnotify"
)

// processEntry tracks an in-flight process for heartbeat-based cleanup.
type processEntry struct {
	cmd          *exec.Cmd
	pgid         int
	killedByHost bool
	killSignal   string
}

// activeRequests tracks the number of in-flight requests.
var activeRequests atomic.Int32

// inFlightProcesses maps uuid -> *processEntry for kill operations.
var inFlightProcesses sync.Map

// Default configuration values for heartbeat-based cleanup.
const (
	defaultHeartbeatStale  = 5 * time.Second
	defaultKillGrace       = 5 * time.Second
	defaultShutdownGrace   = 30 * time.Second
	heartbeatCheckInterval = 1 * time.Second
)

const proxyDir = ".swe-swe/proxy"

// heartbeatStale checks if the heartbeat file is stale (missing or older than maxAge).
func heartbeatStale(path string, maxAge time.Duration) bool {
	info, err := os.Stat(path)
	if err != nil {
		return true // Missing file is considered stale
	}
	return time.Since(info.ModTime()) > maxAge
}

// getEnvDuration reads a duration from an environment variable, returning defaultVal if not set or invalid.
func getEnvDuration(name string, defaultVal time.Duration) time.Duration {
	if v := os.Getenv(name); v != "" {
		if d, err := time.ParseDuration(v); err == nil {
			return d
		}
	}
	return defaultVal
}

// killAllInFlight kills all in-flight processes with signal escalation.
// It sends SIGTERM first, waits for grace period, then sends SIGKILL if needed.
// This is a placeholder that will be fully implemented in Phase 3.
func killAllInFlight(grace time.Duration) {
	inFlightProcesses.Range(func(key, value any) bool {
		entry := value.(*processEntry)
		uuid := key.(string)
		fmt.Printf("[proxy] Killing process group %d for request %s\n", entry.pgid, uuid)
		killProcessGroup(entry.pgid, grace)
		entry.killedByHost = true
		entry.killSignal = "SIGTERM"
		return true
	})
}

// killProcessGroup sends SIGTERM to a process group, waits for grace period,
// then sends SIGKILL if the process is still alive.
// This is a placeholder that will be fully implemented in Phase 3.
func killProcessGroup(pgid int, grace time.Duration) {
	// Placeholder - full implementation in Phase 3
	// For now, just send SIGTERM to the process group
	_ = grace // Will be used in Phase 3 for escalation
	// Signal sending is platform-specific, handled in proxy_unix.go/proxy_windows.go
}

// containerScriptTemplate is the bash script generated for containers to submit requests.
// It uses NUL-delimited arguments and streams stdout/stderr in real-time.
const containerScriptTemplate = `#!/usr/bin/env bash
set -euo pipefail

# Container script for proxying '%s' commands to host
# Generated by: swe-swe proxy %s

PROXY_DIR="${PROXY_DIR:-.swe-swe/proxy}"
TIMEOUT="${PROXY_TIMEOUT:-300}"

# Generate unique request ID
uuid=$(cat /proc/sys/kernel/random/uuid)
req_file="$PROXY_DIR/$uuid.req"
tmp_file="$PROXY_DIR/$uuid.req.tmp"
exit_file="$PROXY_DIR/$uuid.exit"
stdout_file="$PROXY_DIR/$uuid.stdout"
stderr_file="$PROXY_DIR/$uuid.stderr"

# Cleanup function to remove response files
cleanup() {
    rm -f "$stdout_file" "$stderr_file" "$exit_file"
}
trap cleanup EXIT

# Stream file contents as they're written
# Usage: stream_file <file> <output_fd> <stop_flag_file>
stream_file() {
    local file="$1"
    local fd="$2"
    local stop_flag="$3"
    local pos=0
    local size

    while true; do
        if [[ -f "$file" ]]; then
            size=$(stat -c%%s "$file" 2>/dev/null || echo 0)
            if ((size > pos)); then
                # Note: 1>&"$fd" must come before 2>/dev/null due to shell redirection order
                dd if="$file" bs=1 skip="$pos" count=$((size - pos)) 1>&"$fd" 2>/dev/null
                pos=$size
            fi
        fi
        # Check if we should stop
        if [[ -f "$stop_flag" ]]; then
            # One final read to catch any remaining content
            if [[ -f "$file" ]]; then
                size=$(stat -c%%s "$file" 2>/dev/null || echo 0)
                if ((size > pos)); then
                    dd if="$file" bs=1 skip="$pos" count=$((size - pos)) 1>&"$fd" 2>/dev/null
                fi
            fi
            break
        fi
        sleep 0.05
    done
}

# Write request atomically (NUL-delimited arguments)
if [[ $# -gt 0 ]]; then
    printf '%%s\0' "$@" > "$tmp_file"
else
    # No arguments - create empty request file
    touch "$tmp_file"
fi
mv "$tmp_file" "$req_file"

# Wait for stdout/stderr files to be created by host
deadline=$((SECONDS + TIMEOUT))
while [[ ! -f "$stdout_file" ]] || [[ ! -f "$stderr_file" ]]; do
    if ((SECONDS >= deadline)); then
        echo "ERROR: Timeout waiting for host to start command" >&2
        rm -f "$req_file" 2>/dev/null || true
        exit 124
    fi
    if command -v inotifywait &>/dev/null; then
        inotifywait -qq -t 1 -e create -e moved_to "$PROXY_DIR" 2>/dev/null || true
    else
        sleep 0.1
    fi
done

# Start streaming stdout and stderr in background
stream_file "$stdout_file" 1 "$exit_file" &
stdout_pid=$!
stream_file "$stderr_file" 2 "$exit_file" &
stderr_pid=$!

# Wait for exit file (signals command completion)
while [[ ! -f "$exit_file" ]]; do
    if ((SECONDS >= deadline)); then
        echo "ERROR: Timeout waiting for host to complete command" >&2
        kill "$stdout_pid" "$stderr_pid" 2>/dev/null || true
        exit 124
    fi
    sleep 0.05
done

# Wait for streaming to complete
wait "$stdout_pid" 2>/dev/null || true
wait "$stderr_pid" 2>/dev/null || true

# Read exit code (cleanup trap will handle file removal)
exit_code=$(cat "$exit_file")
exit "$exit_code"
`

// handleProxy implements the `swe-swe proxy <command>` subcommand.
// It creates a file-based proxy that allows containers to execute
// the specified command on the host and receive stdout/stderr/exit code.
func handleProxy() {
	// Handle help flags
	if len(os.Args) < 3 || os.Args[2] == "-h" || os.Args[2] == "--help" {
		printProxyHelp()
		if len(os.Args) >= 3 && (os.Args[2] == "-h" || os.Args[2] == "--help") {
			os.Exit(0)
		}
		os.Exit(1)
	}

	command := os.Args[2]

	// Validate command is not empty or a flag
	if command == "" || strings.HasPrefix(command, "-") {
		fmt.Fprintf(os.Stderr, "Error: invalid command %q\n\n", command)
		printProxyHelp()
		os.Exit(1)
	}

	// Create proxy directory if needed
	if err := os.MkdirAll(proxyDir, 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Error: failed to create proxy directory: %v\n", err)
		os.Exit(1)
	}

	pidFile := filepath.Join(proxyDir, command+".pid")
	scriptFile := filepath.Join(proxyDir, command)

	// Check for existing PID file
	if err := checkAndClaimPIDFile(pidFile, command); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	// Generate container script
	if err := generateContainerScript(scriptFile, command); err != nil {
		os.Remove(pidFile)
		fmt.Fprintf(os.Stderr, "Error: failed to generate container script: %v\n", err)
		os.Exit(1)
	}

	// Set up signal handling for graceful shutdown
	ctx, cancel := context.WithCancel(context.Background())
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

	go func() {
		sig := <-sigChan
		fmt.Printf("\n[proxy] Received signal %v, shutting down...\n", sig)
		cancel()
	}()

	// Ensure cleanup on exit
	defer func() {
		os.Remove(scriptFile)
		os.Remove(pidFile)
		fmt.Printf("[proxy] Cleaned up script and PID file\n")
	}()

	// Clean up orphan response files from previous runs
	cleanupOrphanFiles(proxyDir)

	// Get configuration from environment
	staleThreshold := getEnvDuration("PROXY_HEARTBEAT_STALE", defaultHeartbeatStale)
	killGrace := getEnvDuration("PROXY_KILL_GRACE", defaultKillGrace)
	heartbeatFile := filepath.Join(proxyDir, ".heartbeat")

	// Start heartbeat watcher goroutine
	go func() {
		ticker := time.NewTicker(heartbeatCheckInterval)
		defer ticker.Stop()
		for {
			select {
			case <-ctx.Done():
				return
			case <-ticker.C:
				if activeRequests.Load() > 0 && heartbeatStale(heartbeatFile, staleThreshold) {
					info, _ := os.Stat(heartbeatFile)
					var lastMod string
					if info != nil {
						lastMod = fmt.Sprintf("last: %v ago", time.Since(info.ModTime()).Round(time.Second))
					} else {
						lastMod = "file missing"
					}
					fmt.Printf("[proxy] Heartbeat stale (%s), killing %d in-flight processes\n",
						lastMod, activeRequests.Load())
					killAllInFlight(killGrace)
				}
			}
		}
	}()

	fmt.Printf("[proxy] Starting proxy for command: %s\n", command)
	fmt.Printf("[proxy] Container script: %s\n", scriptFile)
	fmt.Printf("[proxy] PID file: %s\n", pidFile)
	fmt.Printf("[proxy] Watching for requests in: %s\n", proxyDir)

	// Set up file watcher
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: failed to create file watcher: %v\n", err)
		os.Exit(1)
	}
	defer watcher.Close()

	// Watch the proxy directory
	if err := watcher.Add(proxyDir); err != nil {
		fmt.Fprintf(os.Stderr, "Error: failed to watch directory: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("[proxy] Listening for '%s' commands... (Ctrl+C to stop)\n", command)

	// WaitGroup for in-flight requests
	var wg sync.WaitGroup

	// Main event loop
	for {
		select {
		case <-ctx.Done():
			fmt.Printf("[proxy] Shutting down gracefully, waiting for in-flight requests...\n")
			wg.Wait()
			fmt.Printf("[proxy] All requests completed\n")
			return

		case event, ok := <-watcher.Events:
			if !ok {
				wg.Wait()
				return
			}

			// We're interested in Create and Rename (moved_to) events for .req files
			if event.Op&(fsnotify.Create|fsnotify.Rename) != 0 {
				if strings.HasSuffix(event.Name, ".req") {
					uuid := strings.TrimSuffix(filepath.Base(event.Name), ".req")
					fmt.Printf("[proxy] Received request: %s\n", uuid)
					wg.Add(1)
					go func(uuid string) {
						defer wg.Done()
						processRequest(command, uuid)
					}(uuid)
				}
			}

		case err, ok := <-watcher.Errors:
			if !ok {
				wg.Wait()
				return
			}
			fmt.Fprintf(os.Stderr, "[proxy] Watcher error: %v\n", err)
		}
	}
}

// generateContainerScript writes the container script to the specified path.
func generateContainerScript(path, command string) error {
	script := fmt.Sprintf(containerScriptTemplate, command, command)
	if err := os.WriteFile(path, []byte(script), 0755); err != nil {
		return fmt.Errorf("failed to write script: %w", err)
	}
	return nil
}

// printProxyHelp prints the help message for the proxy subcommand.
func printProxyHelp() {
	fmt.Fprintf(os.Stderr, `Usage: swe-swe proxy <command>

Starts a file-based proxy that allows containers to execute <command> on the host
and receive stdout/stderr/exit code in real-time.

Arguments:
  <command>    The host command to proxy (e.g., make, docker, npm)

Environment Variables:
  PROXY_TIMEOUT    Timeout in seconds for container script (default: 300)
  PROXY_DIR        Override proxy directory (default: .swe-swe/proxy)

How It Works:
  1. Host runs 'swe-swe proxy <command>' which watches .swe-swe/proxy/ for requests
  2. Container runs '.swe-swe/proxy/<command> [args...]' to submit a request
  3. Host executes the command and streams stdout/stderr back to container
  4. Container receives output in real-time and exits with the command's exit code

File Protocol:
  .swe-swe/proxy/<command>       Generated container script (executable)
  .swe-swe/proxy/<command>.pid   Host PID file (prevents duplicate proxies)
  .swe-swe/proxy/<uuid>.req      Request file (NUL-delimited args)
  .swe-swe/proxy/<uuid>.stdout   Response stdout (streamed)
  .swe-swe/proxy/<uuid>.stderr   Response stderr (streamed)
  .swe-swe/proxy/<uuid>.exit     Exit code (signals completion)

Examples:
  # Host: start proxy for 'make' command
  swe-swe proxy make

  # Container: run make with arguments (output streams in real-time)
  .swe-swe/proxy/make build TARGET=hello

  # Multiple proxies (run in separate terminals)
  swe-swe proxy make
  swe-swe proxy docker
  swe-swe proxy npm

`)
}

// processRequest handles a single proxy request:
// 1. Read NUL-delimited args from <uuid>.req
// 2. Delete .req file (claim it)
// 3. Execute command with args, streaming stdout/stderr to files
// 4. Write exit code to signal completion
func processRequest(command, uuid string) {
	// Track active requests for heartbeat-based cleanup
	activeRequests.Add(1)
	defer activeRequests.Add(-1)

	reqFile := filepath.Join(proxyDir, uuid+".req")
	stdoutFile := filepath.Join(proxyDir, uuid+".stdout")
	stderrFile := filepath.Join(proxyDir, uuid+".stderr")
	exitFile := filepath.Join(proxyDir, uuid+".exit")

	// Read the request file
	data, err := os.ReadFile(reqFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "[proxy] Failed to read request %s: %v\n", uuid, err)
		// Write error to response files
		os.WriteFile(stderrFile, []byte(fmt.Sprintf("Failed to read request: %v\n", err)), 0644)
		os.WriteFile(stdoutFile, []byte{}, 0644)
		os.WriteFile(exitFile, []byte("1"), 0644)
		return
	}

	// Delete request file (claim it)
	os.Remove(reqFile)

	// Parse NUL-delimited arguments
	args := parseNulDelimitedArgs(data)
	fmt.Printf("[proxy] Executing: %s %v\n", command, args)

	// Create output files for streaming
	stdoutF, err := os.Create(stdoutFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "[proxy] Failed to create stdout file: %v\n", err)
		os.WriteFile(exitFile, []byte("1"), 0644)
		return
	}
	defer stdoutF.Close()

	stderrF, err := os.Create(stderrFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "[proxy] Failed to create stderr file: %v\n", err)
		os.WriteFile(exitFile, []byte("1"), 0644)
		return
	}
	defer stderrF.Close()

	// Execute the command with output streaming directly to files
	// Use process group so we can kill the entire tree if needed
	cmd := exec.Command(command, args...)
	cmd.Stdout = stdoutF
	cmd.Stderr = stderrF
	setSysProcAttr(cmd) // Platform-specific process group setup

	// Start the command (don't use Run so we can get the PID)
	if err := cmd.Start(); err != nil {
		exitCode := 127
		stderrF.WriteString(fmt.Sprintf("Failed to execute command: %v\n", err))
		fmt.Printf("[proxy] Command failed to start: %v\n", err)
		os.WriteFile(exitFile, []byte(strconv.Itoa(exitCode)), 0644)
		return
	}

	// Register process for potential kill operations
	entry := &processEntry{
		cmd:  cmd,
		pgid: getProcessGroupID(cmd),
	}
	inFlightProcesses.Store(uuid, entry)
	defer inFlightProcesses.Delete(uuid)

	// Wait for command to complete
	err = cmd.Wait()

	// Determine exit code
	exitCode := 0
	if err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok {
			exitCode = exitErr.ExitCode()
		} else {
			// Unexpected error
			exitCode = 1
		}
	}

	fmt.Printf("[proxy] Command exited with code: %d\n", exitCode)

	// Write exit file last to signal completion
	if err := os.WriteFile(exitFile, []byte(strconv.Itoa(exitCode)), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "[proxy] Failed to write exit code: %v\n", err)
	}
}

// parseNulDelimitedArgs splits a NUL-delimited byte slice into arguments.
// Empty input returns nil (no arguments).
// Trailing NUL bytes are handled gracefully.
func parseNulDelimitedArgs(data []byte) []string {
	if len(data) == 0 {
		return nil
	}

	// Split on NUL bytes
	parts := bytes.Split(data, []byte{0})

	// Filter out empty strings (handles trailing NUL)
	var args []string
	for _, part := range parts {
		if len(part) > 0 {
			args = append(args, string(part))
		}
	}

	return args
}

// checkAndClaimPIDFile checks if a proxy is already running for this command.
// If a stale PID file exists (process dead), it removes it.
// If the process is still running, it returns an error.
// Otherwise, it writes the current PID to the file.
func checkAndClaimPIDFile(pidFile, command string) error {
	// Check if PID file exists
	data, err := os.ReadFile(pidFile)
	if err == nil {
		// PID file exists, check if process is running
		pid, err := strconv.Atoi(strings.TrimSpace(string(data)))
		if err != nil {
			// Invalid PID file content, remove it
			fmt.Printf("[proxy] Removing invalid PID file: %s\n", pidFile)
			os.Remove(pidFile)
		} else {
			// Check if process is alive using signal 0
			process, err := os.FindProcess(pid)
			if err == nil {
				// On Unix, FindProcess always succeeds, so we need to send signal 0
				err = process.Signal(syscall.Signal(0))
				if err == nil {
					// Process is still running
					return fmt.Errorf("proxy for '%s' already running (PID %d)", command, pid)
				}
			}
			// Process is dead, remove stale PID file
			fmt.Printf("[proxy] Removing stale PID file (PID %d no longer running)\n", pid)
			os.Remove(pidFile)
		}
	} else if !os.IsNotExist(err) {
		return fmt.Errorf("failed to read PID file: %v", err)
	}

	// Write our PID to the file
	currentPID := os.Getpid()
	if err := os.WriteFile(pidFile, []byte(strconv.Itoa(currentPID)), 0644); err != nil {
		return fmt.Errorf("failed to write PID file: %v", err)
	}

	return nil
}

// cleanupOrphanFiles removes orphan response files older than 5 minutes.
// Orphans can occur when:
// - Container crashed after submitting request but before reading response
// - Host crashed after writing response but before container read it
// We only clean up response files (.stdout, .stderr, .exit), not .req files
// since those might be legitimate pending requests.
func cleanupOrphanFiles(dir string) {
	const maxAge = 5 * time.Minute

	entries, err := os.ReadDir(dir)
	if err != nil {
		// Directory might not exist yet, that's fine
		return
	}

	now := time.Now()
	orphanSuffixes := []string{".stdout", ".stderr", ".exit"}

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		name := entry.Name()
		isOrphanCandidate := false
		for _, suffix := range orphanSuffixes {
			if strings.HasSuffix(name, suffix) {
				isOrphanCandidate = true
				break
			}
		}

		if !isOrphanCandidate {
			continue
		}

		info, err := entry.Info()
		if err != nil {
			continue
		}

		age := now.Sub(info.ModTime())
		if age > maxAge {
			path := filepath.Join(dir, name)
			if err := os.Remove(path); err == nil {
				fmt.Printf("[proxy] Removed orphan file: %s (age: %v)\n", name, age.Round(time.Second))
			}
		}
	}
}
