[{"name":"DebugHub","comment":" DebugHub — the message router inside agent-reverse-proxy.\n\nManages three subscriber pools:\n\n  - **UI observers:** terminal-ui instances connected via `/ui` (WS 3,4)\n  - **Shell page:** connected via `/ws` (WS 5)\n  - **inject.js:** connected via `/ws` (WS 6)\n\nRouting rules:\n\n    Source               -> Destination\n    Shell page sends     -> BroadcastToUiObservers (FromShellPage msg)\n    inject.js sends      -> BroadcastToUiObservers (FromInject msg)\n    HTTP GET /open       -> SendToUiObserversOnly (Open)\n    UI Navigate/Reload   -> ForwardToShellPage\n    UI Query             -> ForwardToInject\n\n@docs Effect, onShellPageMessage, onInjectMessage, onOpenRequest, onUiCommand\n\n","unions":[{"name":"Effect","comment":" Side effects produced by the DebugHub routing logic.\n","args":[],"cases":[["BroadcastToUiObservers",["DebugProtocol.AllDebugMsg"]],["SendToUiObserversOnly",["DebugProtocol.AllDebugMsg"]],["ForwardToShellPage",["DebugProtocol.ShellPageCommand"]],["ForwardToInject",["DebugProtocol.InjectCommand"]]]}],"aliases":[],"values":[{"name":"onInjectMessage","comment":" When inject.js (WS 6) sends a message, the hub\nbroadcasts it to all UI observers as a AllDebugMsg.\n","type":"DebugProtocol.InjectJsDebugMsg -> List.List DebugHub.Effect"},{"name":"onOpenRequest","comment":" When the swe-swe-open CLI shim hits `HTTP GET /open?url=...`,\nthe hub broadcasts an `Open` message to all UI observers.\nThis is the source of the duplicate-prompt bug — all terminal-ui\ninstances receive and handle it.\n","type":"{ url : Domain.Url } -> List.List DebugHub.Effect"},{"name":"onShellPageMessage","comment":" When the shell page (WS 5) sends a message, the hub\nbroadcasts it to all UI observers as a AllDebugMsg.\n","type":"DebugProtocol.ShellPageDebugMsg -> List.List DebugHub.Effect"},{"name":"onUiCommand","comment":" When a UI observer (WS 3,4) sends a command, the hub\nroutes it to the appropriate iframe client:\nNavigate/Reload → shell page, Query → inject.js.\n","type":"DebugProtocol.UiCommand -> List.List DebugHub.Effect"}],"binops":[]},{"name":"DebugProtocol","comment":" Debug channel protocol types, split by client.\n\nShell page (WS 5) handles navigation: page loads, URL changes, back/forward.\ninject.js (WS 6) handles telemetry: console, errors, network, DOM queries.\nAllDebugMsg is the aggregate that UI observers (terminal-ui on WS 3,4) receive.\n\nEndpoints (path-based on swe-swe-server :9898, via embedded agent-reverse-proxy):\n\n    /proxy/{uuid}/preview/__agent-reverse-proxy-debug__/ui        (WS 3,4)\n    /proxy/{uuid}/preview/__agent-reverse-proxy-debug__/ws?role=shell   (WS 5)\n    /proxy/{uuid}/preview/__agent-reverse-proxy-debug__/ws?role=inject  (WS 6)\n\nAll messages use JSON with a `t` (type) discriminator field.\n\n@docs ShellPageDebugMsg, ShellPageCommand\n@docs InjectJsDebugMsg, InjectCommand, FetchResult, XhrResult\n@docs AllDebugMsg, UiCommand, NavigateAction\n\n","unions":[{"name":"AllDebugMsg","comment":" Messages received by UI observers (terminal-ui) from the hub.\nAggregate of all sources: shell page, inject.js, and HTTP /open.\n","args":[],"cases":[["FromShellPage",["DebugProtocol.ShellPageDebugMsg"]],["FromInject",["DebugProtocol.InjectJsDebugMsg"]],["Open",["{ url : Domain.Url }"]]]},{"name":"FetchResult","comment":" Result of a Fetch API call.\nSuccess carries status + ok; failure (network error, abort) carries error string.\n","args":[],"cases":[["FetchResult",["{ request : { url : Domain.Url, method : String.String, ms : Basics.Int, ts : Domain.Timestamp }, response : Result.Result { error : String.String } { status : Basics.Int, ok : Basics.Bool } }"]]]},{"name":"InjectCommand","comment":" Commands sent by the hub to inject.js.\n","args":[],"cases":[["DomQuery",["{ id : String.String, selector : String.String }"]]]},{"name":"InjectJsDebugMsg","comment":" Messages sent by inject.js to the hub.\nTelemetry: console output, errors, network activity, DOM query results.\n","args":[],"cases":[["Console",["{ m : String.String, args : List.List String.String, ts : Domain.Timestamp }"]],["Error",["{ msg : String.String, file : String.String, line : Basics.Int, col : Basics.Int, stack : Maybe.Maybe String.String, ts : Domain.Timestamp }"]],["Rejection",["{ reason : String.String, ts : Domain.Timestamp }"]],["Fetch",["DebugProtocol.FetchResult"]],["Xhr",["DebugProtocol.XhrResult"]],["QueryResult",["{ id : String.String, found : Basics.Bool, text : Maybe.Maybe String.String, html : Maybe.Maybe String.String, visible : Basics.Bool, rect : Maybe.Maybe { x : Basics.Float, y : Basics.Float, width : Basics.Float, height : Basics.Float } }"]],["WsUpgrade",["{ from : Domain.Url, to : Domain.Url, ts : Domain.Timestamp }"]]]},{"name":"NavigateAction","comment":" Navigation direction.\n","args":[],"cases":[["ToUrl",["Domain.Url"]],["Back",[]],["Forward",[]]]},{"name":"ShellPageCommand","comment":" Commands sent by the hub to the shell page.\n","args":[],"cases":[["ShellNavigate",["DebugProtocol.NavigateAction"]],["ShellReload",[]]]},{"name":"ShellPageDebugMsg","comment":" Messages sent by the shell page to the hub.\nNavigation-related: page loads, URL changes, back/forward state.\n","args":[],"cases":[["Init",["{ url : Domain.Url, ts : Domain.Timestamp }"]],["UrlChange",["{ url : Domain.Url, ts : Domain.Timestamp }"]],["NavState",["{ canGoBack : Basics.Bool, canGoForward : Basics.Bool }"]]]},{"name":"UiCommand","comment":" Commands sent by terminal-ui to the hub (on WS 3,4).\nThe hub routes Navigate/Reload to the shell page, Query to inject.js.\n","args":[],"cases":[["Navigate",["DebugProtocol.NavigateAction"]],["Reload",[]],["Query",["{ id : String.String, selector : String.String }"]]]},{"name":"XhrResult","comment":" Result of an XMLHttpRequest.\nXHR `loadend` always fires — even network failures report status 0.\nThere is no error branch; ok = status >= 200 && status < 300.\n","args":[],"cases":[["XhrResult",["{ request : { url : Domain.Url, method : String.String, ms : Basics.Int, ts : Domain.Timestamp }, status : Basics.Int, ok : Basics.Bool }"]]]}],"aliases":[],"values":[],"binops":[]},{"name":"Domain","comment":" Shared primitive types used across the architecture.\n\nSystem overview:\n\n  - Browser page hosts 2x terminal-ui web components + 1x Preview iframe\n  - Container runs swe-swe-server (PTY + embedded preview/agentchat proxy)\n  - 4 WebSockets + 1 HTTP endpoint connect them (+ 2 more when Preview iframe active)\n  - Proxies reachable via two modes (browser auto-selects):\n      - Port-based (preferred): per-port listeners e.g. :23000, :24000\n      - Path-based (fallback): /proxy/{uuid}/preview/ on main server port\n  - Both modes reach the same proxy instance and share a DebugHub\n\n@docs Url, Path, SessionUuid, PreviewPort, AgentChatPort, ProxyPortOffset, PreviewProxyPort, AgentChatProxyPort, Bytes, Timestamp, ServerAddr\n\n","unions":[{"name":"AgentChatPort","comment":" Port where the MCP sidecar (agent chat backend) listens.\nDerived from preview port: `previewPort + 1000`.\n","args":[],"cases":[["AgentChatPort",["Basics.Int"]]]},{"name":"AgentChatProxyPort","comment":" Per-port proxy listener for the agent chat proxy.\n\n    agentChatProxyPort = agentChatPort + proxyPortOffset\n    e.g., 4000 + 20000 = 24000\n\nTraefik forwards host port 24000 → container port 24000 → swe-swe-server\nlistener → MCP sidecar :4000.\n\n","args":[],"cases":[["AgentChatProxyPort",["Basics.Int"]]]},{"name":"Bytes","comment":" Opaque binary data — PTY I/O, file upload/download chunks.\nNot JSON-encoded; sent as WebSocket binary frames.\n","args":[],"cases":[["Bytes",[]]]},{"name":"Path","comment":" URL path with query and fragment (no scheme, host, or port).\n\nExtracted from a full Url by stripping `localhost:{port}` or the proxy prefix.\nUsed by the Preview URL bar which shows a fixed `localhost:{PreviewPort}` prefix\nand an editable path — the port is NEVER derived from the incoming URL because\nthe preview proxy can only target one port per session.\n\n","args":[],"cases":[["Path",["String.String"]]]},{"name":"PreviewPort","comment":" Port number for the preview dev server.\nReceived via `StatusPayload.previewPort` on the PTY WebSocket.\n","args":[],"cases":[["PreviewPort",["Basics.Int"]]]},{"name":"PreviewProxyPort","comment":" Per-port proxy listener for the preview proxy.\n\n    previewProxyPort = previewPort + proxyPortOffset\n    e.g., 3000 + 20000 = 23000\n\nTraefik forwards host port 23000 → container port 23000 → swe-swe-server\nlistener → user app :3000.\n\n","args":[],"cases":[["PreviewProxyPort",["Basics.Int"]]]},{"name":"ProxyPortOffset","comment":" Offset added to app ports to derive per-port proxy listener ports.\n\n    Default: 20000 (configurable via `--proxy-port-offset` at init time)\n    Constraint: offset >= 1024, offset + 5019 < 65536\n\nStored in `.env` as `SWE_PROXY_PORT_OFFSET`.\n\n","args":[],"cases":[["ProxyPortOffset",["Basics.Int"]]]},{"name":"ServerAddr","comment":" Container-internal address where swe-swe-server listens.\n\n    localhost:9898\n\nConfigured in:\n\n  - main.go: `-addr` flag (default `:9898`)\n  - docker-compose.yml: `loadbalancer.server.port=9898`\n  - entrypoint.sh: bridge `--bridge http://localhost:9898/...`\n  - entrypoint.sh: open shim `curl http://localhost:9898/...`\n\nThe stdio bridge, open shim, and proxy chains all target this address.\n\n","args":[],"cases":[["ServerAddr",[]]]},{"name":"SessionUuid","comment":" Session identifier — each terminal-ui instance gets a unique UUID.\n","args":[],"cases":[["SessionUuid",["String.String"]]]},{"name":"Timestamp","comment":" Millisecond timestamp from `Date.now()`.\nUsed by inject.js and terminal-ui for telemetry timing.\n","args":[],"cases":[["Timestamp",["Basics.Int"]]]},{"name":"Url","comment":" URL string wrapper. Prevents mixing with other strings.\n","args":[],"cases":[["Url",["String.String"]]]}],"aliases":[],"values":[],"binops":[]},{"name":"HttpProxy","comment":" HTTP Proxy Architecture — port derivation, dual-mode routing, and readiness probing.\n\nTwo reverse proxy chains sit between browser and backend apps. Each is\nreachable via **two modes** — the browser auto-selects at runtime:\n\n    Port-based (preferred, per-origin isolation):\n      Preview:     Browser → Traefik :23000 → swe-swe-server :23000 → User app :3000\n      Agent Chat:  Browser → Traefik :24000 → swe-swe-server :24000 → MCP sidecar :4000\n\n    Path-based (fallback, when per-port listeners are unreachable):\n      Preview:     Browser → Traefik :1977 → swe-swe-server :9898 /proxy/{uuid}/preview/    → User app :3000\n      Agent Chat:  Browser → Traefik :1977 → swe-swe-server :9898 /proxy/{uuid}/agentchat/  → MCP sidecar :4000\n\nBoth modes reach the **same proxy instance** — a path-based proxy and a\nport-based proxy share a single DebugHub per session. The port-based\nproxy uses an empty BasePath (no URL rewriting needed); the path-based\nproxy uses `/proxy/{uuid}/preview` as BasePath for URL rewriting.\n\nPreview proxy: hosted inside swe-swe-server as an embedded Go library\n(`github.com/choonkeat/agent-reverse-proxy`). Each session gets two\ninstances that share a DebugHub.\n\nAgent Chat proxy: hosted inside swe-swe-server as a handler that\nforwards HTTP and relays WebSocket upgrades. Cookie Domain/Secure\nstripping, no HTML injection. Port-based and path-based reach the\nsame `agentChatProxyHandler`.\n\nCORS: Port-based is cross-origin (browser on :1977, proxy on :23000),\nso per-port handlers are wrapped in `corsWrapper` that sets\n`Access-Control-Allow-Origin`, `-Credentials`, `-Methods`, `-Headers`.\nPath-based is same-origin — no CORS needed.\n\nBoth proxies set `X-Agent-Reverse-Proxy` on every response (including 502),\nso browser probes can detect when the proxy handler is active.\n\nPort derivation:\n\n    agentChatPort     = previewPort + 1000          (e.g., 4000)\n    previewProxyPort  = previewPort + portOffset     (e.g., 23000)\n    agentChatProxyPort = agentChatPort + portOffset  (e.g., 24000)\n\nAI agents always use the internal path-based URL (container-internal,\nnever through Traefik), so they work regardless of browser mode.\n\n@docs agentChatPort, previewProxyPort, agentChatProxyPort\n@docs ProxyMode, ProbeResult, classifyProbe, PlaceholderDismiss\n\n","unions":[{"name":"PlaceholderDismiss","comment":" How a placeholder overlay gets dismissed after probe succeeds.\n\nBoth panels show a placeholder (\"Connecting to preview/chat...\") over the\niframe while probing. After probe success, `iframe.src` is set and the\nplaceholder waits for a dismissal event.\n\nPreview has two paths; Agent Chat has one:\n\n    Preview:      DebugWebSocket (urlchange | init)  — primary\n                  IframeOnLoad                       — fallback\n\n    Agent Chat:   IframeOnLoad                       — only path\n\nPlaceholder CSS: both share `.terminal-ui__iframe-placeholder`.\nPreview scopes to `.terminal-ui__iframe-container .terminal-ui__iframe-placeholder`.\nAgent Chat uses `.terminal-ui__agent-chat-placeholder`.\n\n","args":[],"cases":[["DebugWebSocket",[]],["IframeOnLoad",[]]]},{"name":"ProbeResult","comment":" What a probe response tells us about the proxy chain.\n\nThe browser calls `probeUntilReady(url, { method: 'GET', ... })` — uses GET\n(not the default HEAD) to avoid an iOS Safari CORS preflight bug.\nRetries up to 10 times with exponential backoff (2 s → 30 s).\nOn each response, checks `resp.headers.has('X-Agent-Reverse-Proxy')`.\n\nPath-based probes are same-origin — headers always readable. Port-based\nprobes are cross-origin, but `corsWrapper` sets `Access-Control-Expose-Headers`\nso the `X-Agent-Reverse-Proxy` header is visible.\n\n","args":[],"cases":[["ProxyReady",[]],["NotReady",[]]]},{"name":"ProxyMode","comment":" Which proxy mode the browser is using for a session.\n\nThe browser discovers this via a two-phase probe:\n\n1.  **Path probe** — `probeUntilReady(pathBasedUrl)`. Checks if the proxy\n    handler is active (target app may or may not be up). Retries with\n    exponential backoff. If this fails, neither mode works yet.\n\n2.  **Port probe** — once path probe succeeds, single fetch to port-based\n    URL (e.g., `https://hostname:23000/`). If `X-Agent-Reverse-Proxy`\n    header present → PortBased. Otherwise → PathBased.\n\nThe decided mode is stored for the session. All subsequent URL\nconstruction (iframe src, debug WebSocket, agent chat) follows the\nchosen mode consistently.\n\nWhy path-first: the path-based URL is always reachable (main server port).\nBy probing it first, we know the proxy handler exists. The port probe then\njust checks reachability of the dedicated port.\n\n","args":[],"cases":[["PortBased",[]],["PathBased",[]]]}],"aliases":[],"values":[{"name":"agentChatPort","comment":" Agent chat app port = preview port + 1000.\n\n    agentChatPort (PreviewPort 3000) == AgentChatPort 4000\n\n","type":"Domain.PreviewPort -> Domain.AgentChatPort"},{"name":"agentChatProxyPort","comment":" Per-port proxy listener port for agent chat.\n\n    agentChatProxyPort (ProxyPortOffset 20000) (AgentChatPort 4000) == AgentChatProxyPort 24000\n\n","type":"Domain.ProxyPortOffset -> Domain.AgentChatPort -> Domain.AgentChatProxyPort"},{"name":"classifyProbe","comment":" Classify a probe response by the presence of `X-Agent-Reverse-Proxy`.\n","type":"{ hasReverseProxyHeader : Basics.Bool } -> HttpProxy.ProbeResult"},{"name":"previewProxyPort","comment":" Per-port proxy listener port for preview.\n\n    previewProxyPort (ProxyPortOffset 20000) (PreviewPort 3000) == PreviewProxyPort 23000\n\n","type":"Domain.ProxyPortOffset -> Domain.PreviewPort -> Domain.PreviewProxyPort"}],"binops":[]},{"name":"PreviewIframe","comment":" Preview iframe — the shell page and inject.js inside the Preview tab.\n\nTwo processes connect via WS 5,6:\n\n  - **shell page** (`shellPageHTML`) — outer wrapper managing back/forward nav\n  - **inject.js** (`debugInjectJS`) — injected into every proxied HTML page\n\nBoth connect to the same endpoint with a `?role=` query parameter:\n\n    shell page: /__agent-reverse-proxy-debug__/ws?role=shell   (WS 5)\n    inject.js:  /__agent-reverse-proxy-debug__/ws?role=inject  (WS 6)\n\nEach client sends and receives only its own message types:\n\n  - Shell page sends `ShellPageDebugMsg`, receives `ShellPageCommand`\n  - inject.js sends `InjectJsDebugMsg`, receives `InjectCommand`\n\n@docs ShellPageEffect, onPageLoad, onUrlChange, onNavStateChange\n@docs ShellPageAction, onShellCommand\n@docs InjectEffect, onConsole, onError, onRejection, onFetch, onXhr, onWsUpgrade\n@docs InjectAction, onInjectCommand\n\n","unions":[{"name":"InjectAction","comment":" Actions inject.js takes when it receives a command from the hub.\n","args":[],"cases":[["RunQuery",["{ id : String.String, selector : String.String }"]]]},{"name":"InjectEffect","comment":" Effects produced by inject.js — sends telemetry messages to the hub.\n","args":[],"cases":[["InjectSend",["DebugProtocol.InjectJsDebugMsg"]]]},{"name":"ShellPageAction","comment":" Actions the shell page takes when it receives a command from the hub.\n","args":[],"cases":[["NavigateIframe",["DebugProtocol.NavigateAction"]],["ReloadIframe",[]]]},{"name":"ShellPageEffect","comment":" Effects produced by the shell page — sends navigation messages to the hub.\n","args":[],"cases":[["ShellSend",["DebugProtocol.ShellPageDebugMsg"]]]}],"aliases":[],"values":[{"name":"onConsole","comment":" Captured console output (log/warn/error/info/debug).\n","type":"{ m : String.String, args : List.List String.String, ts : Domain.Timestamp } -> PreviewIframe.InjectEffect"},{"name":"onError","comment":" Uncaught error.\n","type":"{ msg : String.String, file : String.String, line : Basics.Int, col : Basics.Int, stack : Maybe.Maybe String.String, ts : Domain.Timestamp } -> PreviewIframe.InjectEffect"},{"name":"onFetch","comment":" Fetch request/response — success (status + ok) or failure (error string).\n","type":"DebugProtocol.FetchResult -> PreviewIframe.InjectEffect"},{"name":"onInjectCommand","comment":" Handle a command from the hub on WS 6.\n","type":"DebugProtocol.InjectCommand -> PreviewIframe.InjectAction"},{"name":"onNavStateChange","comment":" On navigation state change, sends `NavState` with back/forward availability.\n","type":"{ canGoBack : Basics.Bool, canGoForward : Basics.Bool } -> PreviewIframe.ShellPageEffect"},{"name":"onPageLoad","comment":" On page load, the shell page sends an `Init` message with the current URL.\n","type":"{ url : Domain.Url, now : Domain.Timestamp } -> PreviewIframe.ShellPageEffect"},{"name":"onRejection","comment":" Unhandled promise rejection.\n","type":"{ reason : String.String, ts : Domain.Timestamp } -> PreviewIframe.InjectEffect"},{"name":"onShellCommand","comment":" Handle a command from the hub on WS 5.\n","type":"DebugProtocol.ShellPageCommand -> PreviewIframe.ShellPageAction"},{"name":"onUrlChange","comment":" On URL change (pushState/popstate/hashchange), sends `UrlChange`.\n","type":"{ url : Domain.Url, now : Domain.Timestamp } -> PreviewIframe.ShellPageEffect"},{"name":"onWsUpgrade","comment":" Notification that a `ws://` URL was auto-upgraded to `wss://`.\n","type":"{ from : Domain.Url, to : Domain.Url, ts : Domain.Timestamp } -> PreviewIframe.InjectEffect"},{"name":"onXhr","comment":" XMLHttpRequest — always completes with status + ok (no error branch).\n","type":"DebugProtocol.XhrResult -> PreviewIframe.InjectEffect"}],"binops":[]},{"name":"PtyProtocol","comment":" WS 1,2 — PTY WebSocket protocol.\n\nEndpoint: `/ws/{uuid}` on swe-swe-server (:9898).\nOne connection per terminal-ui instance, unique UUID.\n\n    terminal-ui #1 (Agent Terminal) <-> swe-swe-server  via /ws/{uuid1}\n    terminal-ui #2 (Terminal)       <-> swe-swe-server  via /ws/{uuid2}\n\nCarries: binary PTY data (xterm I/O) + JSON control messages.\n\n@docs ClientMsg, ServerMsg, StatusPayload, ExitPayload, FileUploadResult\n\n","unions":[{"name":"ClientMsg","comment":" Messages sent by terminal-ui to swe-swe-server.\nBinary messages carry raw PTY input; JSON messages carry control commands.\n","args":[],"cases":[["PtyInput",["Domain.Bytes"]],["Resize",["{ cols : Basics.Int, rows : Basics.Int }"]],["FileUpload",["{ filename : String.String, data : Domain.Bytes }"]],["Ping",[]],["RenameSession",["{ name : String.String }"]],["ToggleYolo",[]],["Chat",["{ userName : String.String, text : String.String }"]]]},{"name":"ServerMsg","comment":" Messages received by terminal-ui from swe-swe-server.\nThe `Status` message is critical — its `previewPort` triggers\n`connectDebugWebSocket()`, opening WS 3/4 to the agent-reverse-proxy.\n","args":[],"cases":[["PtyOutput",["Domain.Bytes"]],["Pong",[]],["Status",["PtyProtocol.StatusPayload"]],["ChatMsg",["{ userName : String.String, text : String.String, timestamp : String.String }"]],["FileUploaded",["PtyProtocol.FileUploadResult"]],["Exit",["PtyProtocol.ExitPayload"]]]}],"aliases":[{"name":"ExitPayload","comment":" Exit message payload — exit code plus optional worktree info.\n","args":[],"type":"{ exitCode : Basics.Int, worktree : Maybe.Maybe { path : String.String, branch : String.String, targetBranch : String.String } }"},{"name":"FileUploadResult","comment":" Result of a file upload — success with filename or failure with error.\n","args":[],"type":"{ filename : String.String, result : Result.Result { error : String.String } {} }"},{"name":"StatusPayload","comment":" Payload of the `status` JSON message.\nDelivered periodically by swe-swe-server.\n`sessionUUID` is used by the browser to build path-based proxy URLs.\n`ports.preview` triggers the debug WebSocket connection to agent-reverse-proxy.\n\nNote: the wire format is flat JSON (`previewPort`, `agentChatPort` as top-level keys).\nThe nesting here groups related fields for clarity (see HOW-TO.md §3.14).\n`agentChatPort` is `0` on the wire for terminal sessions (JS treats as falsy).\n\n","args":[],"type":"{ sessionUUID : Domain.SessionUuid, ports : { preview : Domain.PreviewPort, agentChat : Domain.AgentChatPort }, terminal : { cols : Basics.Int, rows : Basics.Int }, session : { name : String.String, uuidShort : String.String, workDir : String.String, assistant : String.String, viewers : Basics.Int }, features : { yoloMode : Basics.Bool, yoloSupported : Basics.Bool } }"}],"values":[],"binops":[]},{"name":"TerminalUi","comment":" terminal-ui — custom web component mounted in the browser.\n\nTwo instances are active simultaneously:\n\n  - **#1** Agent Terminal (assistant session)\n  - **#2** Terminal (shell session)\n\nEach instance opens TWO WebSocket connections:\n\n    this.ws       -> WS 1/2  /ws/{uuid}        -> swe-swe-server     (PTY)\n    this._debugWs -> WS 3/4  /.../debug.../ui   -> agent-reverse-proxy (preview)\n\nTotal: 4 WebSockets from 2 terminal-ui instances.\n\n@docs State, Connection, Effect\n@docs onPtyMessage, onDebugMessage\n\n","unions":[{"name":"Connection","comment":" The two WebSocket connections each terminal-ui instance maintains.\n","args":[],"cases":[["PtyWs",["Domain.SessionUuid"]],["DebugUiWs",["Domain.PreviewPort"]]]},{"name":"Effect","comment":" Side effects produced by terminal-ui message handlers.\n\n**Invariant:** The preview URL bar is split into a fixed prefix\n(`localhost:{PreviewPort}`) and an editable Path. The port shown\nin the URL bar is ALWAYS `state.preview.port_` — never extracted\nfrom the incoming Url. This prevents xdg-open or other sources\nfrom injecting a misleading port (e.g. AgentChatPort 4000 when\nPreviewPort is 3000).\n\n","args":[],"cases":[["SendPty",["PtyProtocol.ClientMsg"]],["SendDebug",["DebugProtocol.UiCommand"]],["UpdateUrlBar",["Domain.Path"]],["EnableBackButton",["Basics.Bool"]],["EnableForwardButton",["Basics.Bool"]],["OpenIframePane",["{ pane : String.String, url : Domain.Url }"]],["ConfirmExternalUrl",["Domain.Url"]],["ConnectDebugWebSocket",["Domain.PreviewPort"]]]}],"aliases":[{"name":"State","comment":" Per-instance state of a terminal-ui component.\n","args":[],"type":"{ session : { uuid : Domain.SessionUuid, name : String.String, workDir : String.String, assistant : String.String, viewers : Basics.Int }, preview : { port_ : Maybe.Maybe Domain.PreviewPort, agentChatPort : Maybe.Maybe Domain.AgentChatPort, url : Maybe.Maybe Domain.Url, canGoBack : Basics.Bool, canGoForward : Basics.Bool }, features : { yoloMode : Basics.Bool, yoloSupported : Basics.Bool } }"}],"values":[{"name":"onDebugMessage","comment":" Handle a message from the Debug UI WebSocket (WS 3/4).\n\nOnly 4 message types are actually acted on by terminal-ui:\n`UrlChange`, `Init`, `NavState`, and `Open`.\nThe rest (`Console`, `Error`, `Fetch`, etc.) are ignored here —\nthey are consumed by MCP tools via in-process subscribers.\n\n**BUG:** `Open` is broadcast to ALL UI observers by DebugHub.\nWith 2 terminal-ui instances, both receive the message,\nboth call `openIframePane -> setPreviewURL -> confirm()`.\nResult: 2x \"Open in new tab?\" dialogs for external URLs.\n\n**Note:** `Init` and `UrlChange` call `pathFromProxyUrl` to strip the\nproxy prefix and host:port, producing a bare Path. `Open` also goes\nthrough `setPreviewURL` which extracts the path and ignores the port\nfrom the incoming Url.\n\n","type":"{ msg : DebugProtocol.AllDebugMsg, state : TerminalUi.State } -> ( TerminalUi.State, List.List TerminalUi.Effect )"},{"name":"onPtyMessage","comment":" Handle a message from the PTY WebSocket (WS 1/2).\nThe `Status` message delivers `previewPort`, triggering the debug WS connection.\n","type":"{ msg : PtyProtocol.ServerMsg, state : TerminalUi.State } -> ( TerminalUi.State, List.List TerminalUi.Effect )"}],"binops":[]},{"name":"Topology","comment":" System topology — all processes, connections, and message flows.\n\nEnumerates every WebSocket and HTTP endpoint when 2 terminal-ui\ninstances + Preview tab are active.\n\n    WebSocket Topology\n\n    Browser\n    +==========================================================+\n    |                                                          |\n    |  Agent Terminal     Terminal          Preview tab        |\n    |  terminal-ui #1    terminal-ui #2    shell page          |\n    |  ws + _debugWs     ws + _debugWs     inject.js           |\n    |   |       |         |       |         |       |          |\n    |  WS1    WS3       WS2    WS4       WS5     WS6           |\n    |   |       |         |       |         |       |          |\n    +===|=======|=========|=======|=========|=======|==========+\n        |       |         |       |         |       |\n    +===|=======|=========|=======|=========|=======|==========+\n    |   v       v         v       v         v       v          |\n    |  +----------------------------------------------------+  |\n    |  |              swe-swe-server :9898                  |  |\n    |  |  PTY host (WS1, WS2)                               |  |\n    |  |  +----------------------------------------------+  |  |\n    |  |  |  Preview proxy (/proxy/{uuid}/preview/...)   |  |  |\n    |  |  |  Agent chat proxy (/proxy/{uuid}/agentchat/) |  |  |\n    |  |  |  DebugHub (UI obs WS3,WS4 / iframe WS5,WS6)  |  |  |\n    |  |  |  GET/open <-- HTTP                           |  |  |\n    |  |  +----------------------------------------------+  |  |\n    |  +----------------------------------------------------+  |\n    |                                                          |\n    |  +------------------+    +----------------------------+  |\n    |  | swe-swe-open     |    | stdio bridge               |  |\n    |  | (CLI shim)       |    | (agent-reverse-proxy       |  |\n    |  | HTTP → serve |    |  --bridge → server /mcp)\n    |  +------------------+    +----------------------------+  |\n    |                                                Container |\n    +==========================================================+\n\n    HTTP Proxy Chains (dual-mode: browser auto-selects)\n\n    Port-based (preferred, per-origin isolation):\n      Preview:     Browser → Traefik :23000 → swe-swe-server :23000 → User app :3000\n      Agent Chat:  Browser → Traefik :24000 → swe-swe-server :24000 → MCP sidecar :4000\n\n    Path-based (fallback, when per-port listeners are unreachable):\n      Preview:     Browser → Traefik :1977 → swe-swe-server :9898 /proxy/{uuid}/preview/    → User app :3000\n      Agent Chat:  Browser → Traefik :1977 → swe-swe-server :9898 /proxy/{uuid}/agentchat/  → MCP sidecar :4000\n\n    Both modes reach the same proxy instance — path-based and port-based\n    proxies share a single DebugHub per session. Port-based uses empty\n    BasePath (no URL rewriting); path-based uses BasePath for rewriting.\n\n    Port-based is cross-origin (browser on :1977, proxy on :23000) so\n    per-port handlers are wrapped in corsWrapper. Path-based is same-origin.\n\n    AI agents always use the internal path-based URL (container-internal,\n    never through Traefik).\n\n@docs Process, TerminalUi, ShellPage, InjectJs, SweServer\n@docs Traefik, OpenShim, UserApp, McpSidecar, StdioBridge\n@docs WebSocketChannel, OpenEndpointHttp, PreviewProxyChain, AgentChatProxyChain\n@docs ProxyChains\n@docs fullTopology\n\n","unions":[{"name":"InjectJs","comment":" inject.js — injected into every proxied HTML page, captures telemetry (WS 6).\n","args":[],"cases":[["InjectJs",[]]]},{"name":"McpSidecar","comment":" MCP sidecar process — agent chat backend on port `previewPort + 1000`.\n","args":[],"cases":[["McpSidecar",[]]]},{"name":"OpenShim","comment":" swe-swe-open — CLI shim that sends `HTTP GET /open?url=...` to the preview proxy\nendpoint on swe-swe-server (`/proxy/{uuid}/preview/__agent-reverse-proxy-debug__/open`).\n","args":[],"cases":[["OpenShim",["{ target : Domain.ServerAddr }"]]]},{"name":"Process","comment":" A process in the system — wraps all specific process types.\nLocation prefix (Browser/Container/Host) mirrors fullTopology nesting.\n","args":[],"cases":[["BrowserTerminalUi",["Topology.TerminalUi"]],["BrowserShellPage",["Topology.ShellPage"]],["BrowserInjectJs",["Topology.InjectJs"]],["ContainerSweServer",["Topology.SweServer"]],["ContainerOpenShim",["Topology.OpenShim"]],["ContainerUserApp",["Topology.UserApp"]],["ContainerMcpSidecar",["Topology.McpSidecar"]],["ContainerStdioBridge",["Topology.StdioBridge"]],["HostTraefik",["Topology.Traefik"]]]},{"name":"ShellPage","comment":" Shell page — outer wrapper in Preview iframe, manages navigation (WS 5).\n","args":[],"cases":[["ShellPage",[]]]},{"name":"StdioBridge","comment":" Stdio bridge — lightweight relay between AI agent (stdio MCP) and\nswe-swe-server's preview proxy HTTP MCP endpoint.\n\nSpawned as: `npx @choonkeat/agent-reverse-proxy --bridge http://localhost:9898/proxy/$SESSION_UUID/preview/mcp`\n\n","args":[],"cases":[["StdioBridge",["{ target : Domain.ServerAddr }"]]]},{"name":"SweServer","comment":" The swe-swe-server process (PTY host + preview/agentchat proxy).\n\nEach session gets two proxy instances that share a DebugHub:\n\n  - Path-based: `/proxy/{uuid}/preview/...`, `/proxy/{uuid}/agentchat/...` on :9898\n  - Port-based: per-port listeners (e.g., :23000, :24000) with empty BasePath\n\nPort-based listeners are wrapped in `corsWrapper` for cross-origin access.\n\n","args":[],"cases":[["SweServer",["{ addr : Domain.ServerAddr }"]]]},{"name":"TerminalUi","comment":" A terminal-ui web component instance in the browser.\n","args":[],"cases":[["TerminalUi",["{ label : String.String, sessionUuid : Domain.SessionUuid }"]]]},{"name":"Traefik","comment":" Traefik — host-level reverse proxy providing forwardauth.\n\nRoutes the main server port (:9898) plus per-session proxy ports:\n\n  - Main: :1977 → :9898 (path-based proxy, UI, WebSockets)\n  - Preview: :23000 → :23000 (port-based proxy, up to 20 sessions)\n  - Agent Chat: :24000 → :24000 (port-based proxy, up to 20 sessions)\n\nEach per-port entrypoint gets its own Traefik router with forwardauth.\n\n","args":[],"cases":[["Traefik",[]]]},{"name":"UserApp","comment":" The user's application process (e.g., a dev server on port 3000).\n","args":[],"cases":[["UserApp",[]]]},{"name":"WebSocketChannel","comment":" A WebSocket channel between two processes.\n\nAll type parameters are phantom — they exist only at the type level\nto document which processes and message types are valid for each channel.\n\n    ptyAgentTerminal :\n        WebSocketChannel\n            -- server\n            SweServer\n            -- serverMsg\n            PtyProtocol.ServerMsg\n            -- client\n            TerminalUi\n            -- clientMsg\n            PtyProtocol.ClientMsg\n\n","args":["server","serverMsg","client","clientMsg"],"cases":[["WebSocketChannel",[]]]}],"aliases":[{"name":"AgentChatProxyChain","comment":" Agent Chat proxy chain: Browser → proxy → MCP sidecar.\n\nHosted inside swe-swe-server. Cookie stripping, WebSocket relay, no HTML injection.\n\n","args":[],"type":"{ basePath : String.String, appPort : Domain.AgentChatPort, proxyPort : Domain.AgentChatProxyPort }"},{"name":"OpenEndpointHttp","comment":" An HTTP endpoint exposed by a process.\n","args":[],"type":"{ method : String.String, path : String.String }"},{"name":"PreviewProxyChain","comment":" Preview proxy chain: Browser → proxy → User app.\n\nHosted inside swe-swe-server as an embedded Go library (no separate process).\nInjects debug scripts, provides DebugHub, serves shell page.\n\n","args":[],"type":"{ basePath : String.String, appPort : Domain.PreviewPort, proxyPort : Domain.PreviewProxyPort }"},{"name":"ProxyChains","comment":" Both proxy chains bundled, with the shared port offset.\n\nPath-based and port-based proxies share a single DebugHub per session.\nPath-based uses `basePath` for URL rewriting; port-based uses empty BasePath.\n\n","args":[],"type":"{ portOffset : Domain.ProxyPortOffset, preview : Topology.PreviewProxyChain, agentChat : Topology.AgentChatProxyChain }"}],"values":[{"name":"fullTopology","comment":" Full topology with 2 terminals + preview active.\n6 WebSockets + 1 HTTP endpoint + 2 HTTP reverse proxy chains (dual-mode).\n","type":"{ browser : { agentTerminal : Topology.TerminalUi, terminal : Topology.TerminalUi, shellPage : Topology.ShellPage, injectJs : Topology.InjectJs }, container : { sweServer : Topology.SweServer, openShim : Topology.OpenShim, userApp : Topology.UserApp, mcpSidecar : Topology.McpSidecar, stdioBridge : Topology.StdioBridge }, host : { traefik : Topology.Traefik }, channels : { ptyAgentTerminal : Topology.WebSocketChannel Topology.SweServer PtyProtocol.ServerMsg Topology.TerminalUi PtyProtocol.ClientMsg, ptyTerminal : Topology.WebSocketChannel Topology.SweServer PtyProtocol.ServerMsg Topology.TerminalUi PtyProtocol.ClientMsg, debugUiAgentTerminal : Topology.WebSocketChannel Topology.SweServer DebugProtocol.AllDebugMsg Topology.TerminalUi DebugProtocol.UiCommand, debugUiTerminal : Topology.WebSocketChannel Topology.SweServer DebugProtocol.AllDebugMsg Topology.TerminalUi DebugProtocol.UiCommand, debugIframeShellPage : Topology.WebSocketChannel Topology.SweServer DebugProtocol.ShellPageCommand Topology.ShellPage DebugProtocol.ShellPageDebugMsg, debugIframeInjectJs : Topology.WebSocketChannel Topology.SweServer DebugProtocol.InjectCommand Topology.InjectJs DebugProtocol.InjectJsDebugMsg }, openEndpoint : Topology.OpenEndpointHttp, proxies : Topology.ProxyChains }"}],"binops":[]}]