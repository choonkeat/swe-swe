The Problem

The file upload feature saves files to .swe-swe/uploads/ inside /workspace:

```go
// main.go:1159-1160
uploadsDir := ".swe-swe/uploads"
os.MkdirAll(uploadsDir, 0755)
os.WriteFile(filePath, fileData, 0644)
```

The server runs as the app user (non-root) for security. The entrypoint.sh tries to fix permissions by running `chown -R app:app /workspace/.swe-swe` as root before switching users.

On macOS Docker Desktop, bind mounts use a VirtioFS/gRPC-FUSE layer that doesn't support chown — it fails with EPERM, crashing the container before the server starts.

PR #1's Approach (Rejected)

The PR proposed tolerating chown failures and falling back to running as root. The author rejected it themselves, noting: "running root in container is the right fix here as it makes YOLO mode unpalatable."

This reveals an intentional design philosophy — running as root should feel uncomfortable for a system executing AI-generated code.

Options for "The Right" Solution

Option A: tmpfs mount for uploads ⭐ (Recommended)

Uploads are inherently transient — user drops file → Claude processes → conversation continues. There's no need to persist them.

```yml
# docker-compose.yml
volumes:
- type: tmpfs
    target: /workspace/.swe-swe/uploads
    tmpfs:
    mode: 0755
```

Pros:
- Zero permission conflicts — tmpfs is always writable by container processes
- Fast (memory-backed)
- Security benefit: files don't persist after session
- No chown needed

Cons:
- Lost on container restart (acceptable for upload use case)
- Requires compose file changes (generated by swe-swe init)

Option B: Alternative storage path with fallback

Store uploads in a location app user definitely owns:

```go
uploadsDir := "/home/app/.swe-swe/uploads"  // primary
// or fallback to /tmp/.swe-swe/uploads
```

Then send the absolute path to Claude Code (which it already does).

Pros:
- No permission issues
- Simple code change

Cons:
- Files outside workspace (might confuse users looking for uploads)
- Still need to handle the case where `/workspace/.swe-swe` exists but isn't writable

Option C: Pre-create uploads directory during swe-swe init

Have the init command create `.swe-swe/uploads/` on the host before the container ever starts:

```go
// During init, on the host machine
os.MkdirAll(projectDir+"/.swe-swe/uploads", 0755)
```

Since this runs as the host user, the directory will be owned by them. On Linux, if the container's app UID matches (commonly 1000), it works. On macOS, Docker Desktop maps ownership transparently.

Pros:
- Directory exists with correct ownership before container starts
- No runtime permission games

Cons:
- Assumes swe-swe init always runs before container start (true for normal workflow)
- Doesn't help if directory is deleted and user runs swe-swe start

Option D: Remove the chown and accept "mkdir fails for some users"

If the chown fails, the container starts but uploads fail later. Handle this gracefully in the Go code:

```go
if err := os.MkdirAll(uploadsDir, 0755); err != nil {
    // Try fallback location
    uploadsDir = "/tmp/swe-swe-uploads"
    os.MkdirAll(uploadsDir, 0755)
}
```

Pros:
- Container always starts
- Graceful degradation

Cons:
- Users get confusing errors when upload fails
- Need good error messaging

---
My Recommendation: Combine A + C

1. Pre-create .swe-swe/uploads/ during swe-swe init (Option C) — covers the normal case
2. Add a tmpfs overlay for uploads in docker-compose (Option A) — provides bulletproof fallback and better security
3. Remove the chown from entrypoint.sh — it's no longer needed if tmpfs owns the uploads dir

This gives:
- Works on Linux (UID matching + tmpfs)
- Works on macOS (tmpfs bypasses bind mount issues)
- Uploaded files are transient by design (security win)
- Container always starts
- No root fallback needed

What do you think?