# Container-to-Host Command Proxy Design

## Problem Statement

Containers need to execute commands on the host system and receive stdout/stderr results. The current `watcher.bash` approach has limitations:

- Single fixed command per watcher instance
- No dynamic argument passing
- Race conditions when multiple triggers overlap
- No way to capture per-request output when concurrent

## Requirements

### Functional
1. Container can request host to execute commands ad-hoc
2. Container receives stdout, stderr, and exit code from executed commands
3. Support concurrent requests from container
4. Host runs a single long-lived process via `swe-swe proxy <command>`

### Non-Functional
1. Robust against race conditions
2. Host should not become overwhelmed (bounded concurrency)
3. Simple debugging (inspectable state)
4. Minimal dependencies (prefer stdlib/coreutils)
5. Fail-fast with clear error messages

## Design

### Directory Structure

```
.swe-swe/
├── uploads/              # Existing
├── worktrees/            # Existing
└── proxy/
    ├── make              # Generated container script
    ├── make.pid          # Host PID (signals proxy is running)
    ├── <uuid>.req        # Request: args to pass
    ├── <uuid>.stdout     # Response: captured stdout
    ├── <uuid>.stderr     # Response: captured stderr
    └── <uuid>.exit       # Response: exit code (signals completion)
```

### Request File Format

Line-based (one argument per line):

```
# <uuid>.req
build
FOO=123
VERBOSE=1
```

Empty file = no arguments (just base command).

### Protocol

#### Host Side (`swe-swe proxy <command>`)

**Startup:**
1. Create `.swe-swe/proxy/` directory if needed
2. Check for existing `<command>.pid`:
   - If exists and process running → fail fast with error
   - If exists but process dead → remove stale PID file, continue
3. Write own PID to `<command>.pid`
4. Generate container script at `.swe-swe/proxy/<command>`
5. Start watching for `*.req` files

**Main loop:**
1. Watch `.swe-swe/proxy/` for new `*.req` files (inotifywait)
2. On new request `<uuid>.req`:
   a. Read arguments from file
   b. Delete `.req` file (claim it)
   c. Execute `<command> <args...>`
   d. Write stdout to `<uuid>.stdout`
   e. Write stderr to `<uuid>.stderr`
   f. Write exit code to `<uuid>.exit` (last - signals completion)
3. Loop

**Shutdown (SIGINT/SIGTERM):**
1. Delete `.swe-swe/proxy/<command>` (container script)
2. Delete `.swe-swe/proxy/<command>.pid`
3. Exit

#### Container Side (`.swe-swe/proxy/<command>`)

This script is auto-generated by host. Container runs it like:
```bash
.swe-swe/proxy/make build FOO=123
```

**Flow:**
1. Generate UUID: `uuid=$(cat /proc/sys/kernel/random/uuid)`
2. Write request atomically:
   - Write args to `<uuid>.req.tmp` (one per line)
   - `mv <uuid>.req.tmp <uuid>.req`
3. Wait for `<uuid>.exit` to appear (poll with sleep)
4. Read and output:
   - `cat <uuid>.stdout`
   - `cat <uuid>.stderr >&2`
5. Capture exit code from `<uuid>.exit`
6. Cleanup: delete `<uuid>.stdout`, `<uuid>.stderr`, `<uuid>.exit`
7. Exit with captured exit code

**Timeout:**
- Default 300 seconds (configurable via `PROXY_TIMEOUT` env var)
- On timeout: print error, exit 124

### Concurrency Model

**Sequential Processing**
- Host processes one request at a time
- Queue naturally forms as `.req` files accumulate
- Simple, predictable resource usage

UUIDs ensure no race conditions - each request is fully isolated.

### Error Handling

| Scenario | Handling |
|----------|----------|
| Proxy not running | Container script doesn't exist → clear "command not found" |
| Proxy starts while one running | Fail fast: "proxy for 'make' already running (PID 12345)" |
| Host not responding | Container times out after PROXY_TIMEOUT, exits 124 |
| Command fails | Exit code captured and returned to container |
| Host dies mid-execution | PID file stale, container times out, next `swe-swe proxy` cleans up |
| Container dies mid-request | Orphan request processed, response files left (cleaned on next run or manually) |

### Generated Container Script

Template for `.swe-swe/proxy/<command>`:

```bash
#!/usr/bin/env bash
set -euo pipefail

PROXY_DIR="${PROXY_DIR:-.swe-swe/proxy}"
TIMEOUT="${PROXY_TIMEOUT:-300}"

uuid=$(cat /proc/sys/kernel/random/uuid)
req_file="$PROXY_DIR/$uuid.req"
tmp_file="$PROXY_DIR/$uuid.req.tmp"
exit_file="$PROXY_DIR/$uuid.exit"
stdout_file="$PROXY_DIR/$uuid.stdout"
stderr_file="$PROXY_DIR/$uuid.stderr"

# Write request atomically
printf '%s\n' "$@" > "$tmp_file"
mv "$tmp_file" "$req_file"

# Wait for response
deadline=$((SECONDS + TIMEOUT))
while [[ ! -f "$exit_file" ]]; do
    if ((SECONDS >= deadline)); then
        echo "ERROR: Timeout waiting for host to execute command" >&2
        rm -f "$req_file" 2>/dev/null || true
        exit 124
    fi
    sleep 0.1
done

# Output results
[[ -f "$stdout_file" ]] && cat "$stdout_file"
[[ -f "$stderr_file" ]] && cat "$stderr_file" >&2
exit_code=$(cat "$exit_file")

# Cleanup
rm -f "$stdout_file" "$stderr_file" "$exit_file"

exit "$exit_code"
```

### Host Implementation Outline

```bash
# swe-swe proxy <command>

command="$1"
proxy_dir=".swe-swe/proxy"
pid_file="$proxy_dir/$command.pid"
script_file="$proxy_dir/$command"

mkdir -p "$proxy_dir"

# Fail fast if already running
if [[ -f "$pid_file" ]]; then
    existing_pid=$(cat "$pid_file")
    if kill -0 "$existing_pid" 2>/dev/null; then
        echo "ERROR: Proxy for '$command' already running (PID $existing_pid)" >&2
        exit 1
    fi
    rm -f "$pid_file"  # Stale
fi

# Write PID
echo $$ > "$pid_file"

# Generate container script
cat > "$script_file" << 'SCRIPT'
... (template above)
SCRIPT
chmod +x "$script_file"

# Cleanup on exit
cleanup() {
    rm -f "$script_file" "$pid_file"
}
trap cleanup EXIT

# Watch and process
inotifywait -m -e close_write -e moved_to "$proxy_dir" --format '%f' |
while read -r filename; do
    [[ "$filename" == *.req ]] || continue
    uuid="${filename%.req}"

    req_file="$proxy_dir/$filename"
    [[ -f "$req_file" ]] || continue

    mapfile -t args < "$req_file"
    rm -f "$req_file"

    set +e
    "$command" "${args[@]}" \
        >"$proxy_dir/$uuid.stdout" \
        2>"$proxy_dir/$uuid.stderr"
    echo $? > "$proxy_dir/$uuid.exit"
    set -e
done
```

### Usage Examples

**Host (outside container):**
```bash
$ swe-swe proxy make
[proxy] Listening for 'make' commands...
[proxy] Container script: .swe-swe/proxy/make

# Later, Ctrl+C to stop
^C
[proxy] Shutting down...
```

**Container:**
```bash
$ .swe-swe/proxy/make build
# Host runs: make build
# Container sees output

$ .swe-swe/proxy/make test VERBOSE=1
# Host runs: make test VERBOSE=1

$ .swe-swe/proxy/make nonexistent
make: *** No rule to make target 'nonexistent'.  Stop.
$ echo $?
2
```

**Multiple proxies (separate host terminals):**
```bash
# Terminal 1
$ swe-swe proxy make

# Terminal 2
$ swe-swe proxy docker

# Container now has both:
# .swe-swe/proxy/make
# .swe-swe/proxy/docker
```

### Security Considerations

1. **Command Restriction**: Container can only run the specific command the host started proxy for
2. **Argument Safety**: Args passed as array, no shell expansion/injection
3. **Path Traversal**: UUID validated (no `/` characters possible from /proc/sys/kernel/random/uuid)
4. **Resource Limits**: Host can wrap command with `timeout` or `ulimit`

### Dependencies

**Host:**
- bash 4+
- inotifywait (inotify-tools package)
- coreutils

**Container (generated script):**
- bash 4+
- coreutils
- `/proc/sys/kernel/random/uuid` (Linux)

### Future Enhancements

1. **Parallel execution**: Process multiple requests concurrently with worker pool
2. **Streaming output**: Real-time stdout/stderr via named pipes
3. **Request queue status**: `swe-swe proxy status` to show pending requests
4. **Stale cleanup**: Auto-cleanup orphan response files older than N minutes
5. **Allow-list**: Restrict which arguments/targets are permitted

### Testing Plan

1. **Basic flow**: Request → execute → response with correct stdout/stderr/exit
2. **Concurrent requests**: Multiple simultaneous requests, all processed correctly
3. **Timeout**: Host not running, container times out with exit 124
4. **Duplicate proxy**: Second `swe-swe proxy make` fails fast with clear error
5. **Stale PID**: Kill host, restart proxy, stale PID cleaned up
6. **Cleanup on exit**: Ctrl+C host, verify script and PID file removed
7. **Special characters**: Args with spaces, quotes, newlines handled correctly
8. **Exit codes**: Various exit codes (0, 1, 2, 127) propagate correctly
